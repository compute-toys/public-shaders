struct a{pos:vec2f,angle:f32,scale:vec2f,anchor:vec2f}struct ib{dist:f32,color:vec3f}const pb:f32=3.14159265359;const square_col=vec3<f32>(0.773,0.561,0.702);const bigtri1_col=vec3<f32>(0.502,0.749,0.239);const bigtri2_col=vec3<f32>(0.494,0.325,0.545);const midtri_col=vec3<f32>(0.439,0.573,0.235);const smalltri1_col=vec3<f32>(0.604,0.137,0.443);const smalltri2_col=vec3<f32>(0.012,0.522,0.298);const parallelogram_col=vec3<f32>(0.133,0.655,0.420);const ee=vec3f(0.9,0.8,0.7);fn b(yf:vec2f,X:a)->vec2f{var u=yf-X.pos;let Cb=cos(X.angle);let Db=sin(X.angle);u=vec2f(Cb*u.x+Db*u.y,-Db*u.x+Cb*u.y);u-=X.anchor;u/=X.scale;return u;}fn r(mb:f32,j:a)->f32{if (abs(j.scale.x-j.scale.y)<0.001){return mb*j.scale.x;}let jg=max(j.scale.x,j.scale.y)/min(j.scale.x,j.scale.y);if (jg<2.0){let gg=2.0/(1.0/j.scale.x+1.0/j.scale.y);return mb*gg;}return mb*min(j.scale.x,j.scale.y);}fn Ia(fg:vec2f,cg:vec2f,bg:f32)->f32{return distance(fg,cg)-bg;}fn ug(Wf:vec2f,Tf:f32,Fb:a)->f32{let Pf=b(Wf,Fb);let Of=Ia(Pf,vec2f(0.0),Tf);return r(Of,Fb);}fn n(Gf:vec2f,Ff:vec2f)->f32{let wb=abs(Gf)-Ff;let Cf=length(max(wb,vec2f(0.0)));let Bf=min(max(wb.x,wb.y),0.0);return Cf+Bf;}fn H(Af:vec2f,zf:vec2f,Kb:a)->f32{let xf=b(Af,Kb);let wf=n(xf,zf);return r(wf,Kb);}fn Tc(db:vec2<f32>,bb:vec2<f32>,Za:vec2<f32>,Ya:vec2<f32>)->f32{let x:vec2<f32>=Za-bb;let R:vec2<f32>=Ya-Za;let w:vec2<f32>=bb-Ya;let Ha:vec2<f32>=db-bb;let va:vec2<f32>=db-Za;let ya:vec2<f32>=db-Ya;let Rb:vec2<f32>=Ha-x*clamp(dot(Ha,x)/dot(x,x),0.0f,1.0f);let Yb:vec2<f32>=va-R*clamp(dot(va,R)/dot(R,R),0.0f,1.0f);let Zb:vec2<f32>=ya-w*clamp(dot(ya,w)/dot(w,w),0.0f,1.0f);let Xa:f32=sign(x.x*w.y-x.y*w.x);let Re:vec2<f32>=vec2<f32>(dot(Rb,Rb),Xa*(Ha.x*x.y-Ha.y*x.x));let be:vec2<f32>=vec2<f32>(dot(Yb,Yb),Xa*(va.x*R.y-va.y*R.x));let Ke:vec2<f32>=vec2<f32>(dot(Zb,Zb),Xa*(ya.x*w.y-ya.y*w.x));let cc:vec2<f32>=min(min(Re,be),Ke);return -sqrt(cc.x)*sign(cc.y);}fn Vc(we:vec2f,ve:vec2<f32>,ue:vec2<f32>,te:vec2<f32>,ic:a)->f32{let qe=b(we,ic);let oe=Tc(qe,ve,ue,te);return r(oe,ic);}fn Xc(ke:vec2f,oa:f32)->f32{let pa=sqrt(3.0);var k=ke;k.x=abs(k.x);k=k-vec2f(0.5,0.5*pa)*max(k.x+pa*k.y,0.0);k=k-vec2f(clamp(k.x,-0.5*oa*pa,0.5*oa*pa),-0.5*oa);return length(k)*sign(-k.y)-oa*0.1;}fn yg(Ld:vec2f,Gd:f32,Bc:a)->f32{let Ed=b(Ld,Bc);let Bd=Xc(Ed,Gd);return r(Bd,Bc);}fn Ag(od:vec2<f32>,gb:f32,ea:f32)->f32{var O=od;O=abs(O);let eb=sqrt(gb*gb-ea*ea);let md=length(O-vec2<f32>(0.0f,eb))*sign(ea);let ld=length(O-vec2<f32>(-ea,0.0f))-gb;return select(ld,md,(O.y-eb)*ea>O.x*eb);}fn Rc(id:vec2<f32>,Y:f32,V:f32,xa:f32)->f32{let wa=0.5f*(Y*Y-(V-xa)*(V-xa))/(V-xa);var p=id;p.x=abs(p.x);if (p.y<0.0f){return length(p)-V;}if (p.y*wa-p.x*Y>Y*wa){return length(vec2<f32>(p.x,p.y-Y))-xa;}return length(vec2<f32>(p.x+wa,p.y))-(wa+V);}fn Bg(ed:vec2f,Ne:f32,jd:f32,Zd:f32,Nc:a)->f32{let He=b(ed,Nc);let Md=Rc(He,Ne,jd,Zd);return r(Md,Nc);}fn Qc(Ge:vec2f,Ga:vec2f,Mc:f32)->f32{var D=Ge;D.x=abs(D.x);let Ae=length(D)-Mc;let ne=dot(D,Ga);let cd=clamp(ne,0.0,Mc);let fd=Ga*cd;let nd=length(D-fd);let ud=Ga.y*D.x-Ga.x*D.y;let xd=nd*sign(ud);return max(Ae,xd);}fn zg(Kd:vec2f,yc:f32,ad:f32,uc:a)->f32{let Nd=b(Kd,uc);let Vd=Qc(Nd,vec2f(sin(yc),cos(yc)),ad);return r(Vd,uc);}fn Yc(de:vec2f,mc:f32,lc:f32,se:f32)->f32{var P=de;P.x=abs(P.x);let tb=vec2f(sin(mc),cos(mc));let tf=tb.y*P.x>tb.x*P.y;let uf=select(abs(length(P)-lc),length(P-tb*lc),tf);return uf-se;}fn vg(Ef:vec2f,Jf:f32,Kf:f32,Rf:f32,Oc:a)->f32{let Xf=b(Ef,Oc);let kg=Yc(Xf,Jf,Kf,Rf);return r(kg,Oc);}fn Sc(Sf:vec2f,Ta:f32,na:f32)->f32{var y=Sf;y.x=abs(y.x);let Q=Ta*Ta/na;let S=Q*(na-y.y-0.5*Q)/3.0;let qa=y.x*Q*Q/4.0;let Mb=qa*qa-S*S*S;var C=0.0;if (Mb>0.0){let Ob=pow(qa+sqrt(Mb),1.0/3.0);C=Ob+S/Ob;} else{let Pb=sqrt(S);C=2.0*Pb*cos(acos(qa/(S*Pb))/3.0);}C=min(C,Ta);let sf=vec2f(C,na-C*C/Q);return length(y-sf)*sign(Q*(y.y-na)+y.x*y.x);}fn wg(nf:vec2f,lf:f32,jf:f32,Vb:a)->f32{let hf=b(nf,Vb);let af=Sc(hf,lf,jf);return r(af,Vb);}fn xg(Ve:vec2f,Te:f32,Qe:f32,Ie:f32,dc:a)->f32{let Ee=b(Ve,dc);let Ce=Wc(Ee,Te,Qe,Ie);return r(Ce,dc);}fn Wc(ye:vec2<f32>,ra:f32,jc:f32,pe:f32)->f32{let E:vec2<f32>=vec2<f32>(pe,jc);var s:vec2<f32>=ye;if (s.y<0.0f){s=-s;}var T:vec2<f32>=s-E;T.x=T.x-clamp(T.x,-ra,ra);var sa:vec2<f32>=vec2<f32>(dot(T,T),-T.y);let pc:f32=s.x*E.y-s.y*E.x;if (pc<0.0f){s=-s;}var ka:vec2<f32>=s-vec2<f32>(ra,0.0f);ka=ka-E*clamp(dot(ka,E)/dot(E,E),-1.0f,1.0f);sa=min(sa,vec2<f32>(dot(ka,ka),ra*jc-abs(pc)));return sqrt(sa.x)*sign(-sa.y);}struct Zc{dist:f32,point:vec2f}fn La(tc:vec2f)->f32{return dot(tc,tc);}fn Ka(vc:vec2f,wc:vec2f)->f32{return vc.x*wc.y-vc.y*wc.x;}fn Ja(ma:vec2f,hb:vec2f,Ac:vec2f,Fd:vec2f)->Zc{let A=Ac-hb;let o=hb-2.0*Ac+Fd;let Ca=A*2.0;let ha=hb-ma;let cb=1.0/dot(o,o);let F=cb*dot(A,o);let Ic=cb*(2.0*dot(A,A)+dot(ha,o))/3.0;let Rd=cb*dot(ha,A);var Ea=0.0;var la=0.0;var Fa=vec2f(0.0);let t=Ic-F*F;let I=F*(2.0*F*F-3.0*Ic)+Rd;let vf=t*t*t;let eg=I*I;var z=eg+4.0*vf;if (z>=0.0){z=sqrt(z);z=select(-z,z,I<0.0);let Bb=(z-I)/2.0;let Pc=sign(Bb)*pow(abs(Bb),1.0/3.0);var i=Pc-t/Pc;i-=(i*(i*i+3.0*t)+I)/(3.0*i*i+3.0*t);i=clamp(i-F,0.0,1.0);let Ra=ha+(Ca+o*i)*i;Fa=Ra+ma;Ea=La(Ra);la=Ka(Ca+2.0*o*i,Ra);} else{let Lc=sqrt(-t);let Kc=acos(I/(t*Lc*2.0))/3.0;let Ba=cos(Kc);let Jc=sin(Kc)*sqrt(3.0);let U=clamp(vec3f(Ba+Ba,-Jc-Ba,Jc-Ba)*Lc-F,vec3f(0.0),vec3f(1.0));let Oa=ha+(Ca+o*U.x)*U.x;let Hc=La(Oa);let dd=Ka(A+o*U.x,Oa);let fb=ha+(Ca+o*U.y)*U.y;let Gc=La(fb);let gd=Ka(A+o*U.y,fb);if (Hc<Gc){Ea=Hc;la=dd;Fa=Oa+ma;} else{Ea=Gc;la=gd;Fa=fb+ma;}}return Zc(sqrt(Ea)*sign(la),Fa);}const J=0.2;const v=0.05;const B=J/8.66;const kd=0.8;const aa=-J/1.5;const ba=J/1.5;const Fc=0.333*0.5;fn yb(pd:vec2f,qd:a)->f32{let jb=b(pd,qd);let crossCol=vec3(0.0,1.0,1.0);let sd=a(vec2f(0.0,0.0),pb*0.25,vec2f(1.0),vec2f());let td=b(jb,sd);let Ec=n(td,vec2f(B*0.5,(ba-aa)*0.75));if (Ec<0.0){return Ec;}let vd=a(vec2f(0.0,0.0),-pb*0.25,vec2f(1.0),vec2f());let wd=b(jb,vd);let Dc=n(wd,vec2f(B*0.5,(ba-aa)*0.75));if (Dc<0.0){return Dc;}let yd=a(vec2f(0.0,0.0),0.0,vec2f(1.0),vec2f());let zd=b(jb,yd);let Cc=Ia(zd,vec2f(),B*1.5);if (Cc<0.0){return Cc;}return 1e10;}fn xb(Cd:vec2f,Dd:a,N:f32)->ib{let K=b(Cd,Dd);var d=ib(1e10,vec3f(0.0));let Hd=0.256;let Id=N-Hd;let Jd=u32(Id/Fc);let zc=vec3(0.0,1.0,1.0);for(var nb=0u;nb<Jd;nb++){let xc=yb(K,a(vec2f(0.0,-0.21+0.333*f32(nb)),0.0,vec2f(1.0),vec2f()));if (xc<0.0){d.dist=xc;d.color=zc;}}let sc=yb(K,a(vec2f(0.0,-0.71),0.0,vec2f(1.0),vec2f()));if (sc<0.0){d.dist=sc;d.color=zc;}let Od=vec3f(1.0,0.0,0.0);let Pd=a(vec2f(0.0,-1.0+v),0.0,vec2f(1.0),vec2f());let Qd=b(K,Pd);let rc=n(Qd,vec2f(J,v));if (rc<0.0){d.dist=rc;d.color=Od;}let Sd=vec3f(0.0,1.0,0.0);const leftColumnY=-1.0+kd+v*2.0;let Td=a(vec2f(aa,N),0.0,vec2f(1.0),vec2f(0.0,-1.0+v*2.0));let Ud=b(K,Td);let qc=n(Ud,vec2f(B,N));if (qc<0.0){d.dist=qc;d.color=Sd;}let Wd=vec3f(0.0,0.0,1.0);let Xd=a(vec2f(ba,N),0.0,vec2f(1.0),vec2f(0.0,-1.0+v*2.0));let Yd=b(K,Xd);let oc=n(Yd,vec2f(B,N));if (oc<0.0){d.dist=oc;d.color=Wd;}let ae=vec3f(1.0,1.0,0.0);let Oe=a(vec2f(0.0,N*2.0),0.0,vec2f(1.0),vec2f(0.0,-1.0+v));let ce=b(K,Oe);let nc=n(ce,vec2f((ba-aa)*0.5,v*0.5));if (nc<0.0){d.dist=nc;d.color=ae;}return d;}fn G(fe:vec2f,ge:f32,bd:f32)->f32{let ie=a(vec2f(ge,bd),0.0,vec2f(1.0),vec2f());let je=H(fe,vec2f(0.02,0.02),ie);return je;}fn zb(le:vec2f,Me:a)->ib{let m=b(le,Me);var c=ib(1e10,vec3f(0.0));let kc=vec3f(0.95,0.75,0.2);let ua=vec3f(0.95,0.95,0.9);let windowFrameCol=vec3f(0.15,0.15,0.15);let undercarriageCol=vec3f(0.1,0.1,0.1);let re=0.4;let ja=0.055;let bodyY=0.0;let L=0.01;let M=-0.2;let ga=0.1;let lb=min(G(m,M,L),min(G(m,M+ga*1.0,L),min(G(m,M+ga*2.0,L),min(G(m,M+ga*3.0,L),min(G(m,M+ga*4.0,L),G(m,M+ga*5.0,L))))));if (c.dist>lb&&lb<=0){c.color=ua;c.dist=lb;return c;}let xe=a(vec2f(-0.33,0.0),0.0,vec2f(1.0),vec2f());let hc=H(m,vec2f(0.05*0.5,ja-0.01),xe);if (hc<=0){c.color=ua;c.dist=hc;return c;}let ze=a(vec2f(-0.27,0.0),0.0,vec2f(1.0),vec2f());let gc=H(m,vec2f(0.05*0.5,ja-0.01),ze);if (gc<=0){c.color=ua;c.dist=gc;return c;}let Be=a(vec2f(0.0,0.0),0.0,vec2f(1.0),vec2f());let fc=H(m,vec2f(re,ja),Be)-0.01;if (c.dist>fc){c.color=kc;c.dist=fc;}let De=a(vec2f(-0.39,-0.004),pb*0.33,vec2f(1.0),vec2f());let ec=H(m,vec2f(ja*0.5,ja*0.5),De)-0.03;if (c.dist>ec){c.color=kc;c.dist=ec;}let Fe=a(vec2f(-0.43,-0.01),0.0,vec2f(1.0),vec2f());let Ab=Vc(m,vec2f(0.0),vec2f(0.03,0.05),vec2f(0.03,0.0),Fe)-0.01;if (Ab<0.0){c.color=ua;c.dist=Ab;}return c;}fn Uc(Ma:vec2f,Je:a)->vec3f{let g=b(Ma,Je);let Le=0.333+custom.height1;let me=0.333+custom.height2;let he=custom.dist*2.5;let Da=he*0.5;let Pe=a(vec2f(Da,0.0),0.0,vec2f(1.0),vec2f());let bc=xb(Ma,Pe,Le);if (bc.dist<=0.0){return bc.color;}let ab=-Da;let Se=a(vec2f(ab,0.0),0.0,vec2f(1.0),vec2f());let ac=xb(Ma,Se,me);if (ac.dist<=0.0){return ac.color;}let Ue=vec3f(0.9,0.8,0.2);let q=0.05;let l=-1.0+q*2.0+v*2.0+Fc*2.0;let Xe=a(vec2f(0.0,l),0.0,vec2f(1.0),vec2f());let Ye=H(g,vec2f(2.0,q),Xe);let Ze=q*0.5;let circleRadiusVariation=q*0.3;let Xb=0.12;let circleFrequency=2.0;let bf=vec3f(0.2,0.2,0.2);let cf=round(g.x/Xb);let df=Ze;let ef=g.x-Xb*cf;let ff=vec2f(0.0,l);let gf=Ia(vec2f(ef,g.y),ff,df);if (gf<=0.0){return bf;}if (Ye<=0.0){return Ue;}let Wb=l+q+0.018;let Ub=2.5-6.0*custom.train_mov;let kf=a(vec2f(Ub,Wb+0.04),0.0,vec2f(1.0),vec2f());let Tb=zb(g,kf);let mf=a(vec2f(Ub+0.84,Wb+0.04),0.0,vec2f(-1.0,1.0),vec2f());let Sb=zb(g,mf);let pf=Tb.dist;let qf=Sb.dist;if (pf<=0.0){return Tb.color;}if (qf<=0.0){return Sb.color;}let Pa=0.012;let Qb=-0.333+custom.height1*2.0;let Nb=-0.333+custom.height2*2.0;let Lb=(ba-aa)*0.5;let za=vec2f(ab+J-B*2.0,Nb);let ta=vec2f(Da-J+B*2.0,Qb);let ob=vec2f(0.0,l);let ia=vec2f(ab-Lb,Nb);let fa=vec2f(Da+Lb,Qb);let qb=0.008;let sb=0.15;let ub=vec3f(0.6,0.6,0.6);let Df=ta.x-za.x;let Jb=i32(Df/sb);for(var kb=1;kb<Jb;kb++){let e=f32(kb)/f32(Jb);let Hf=(1.0-e)*(1.0-e)*za.x+2.0*(1.0-e)*e*ob.x+e*e*ta.x;let If=(1.0-e)*(1.0-e)*za.y+2.0*(1.0-e)*e*ob.y+e*e*ta.y;let Ib=If;let Hb=l+q;let Lf=(Ib-Hb)*0.5;let Mf=(Ib+Hb)*0.5;let Nf=n(g-vec2f(Hf,Mf),vec2f(qb,Lf));if (Nf<=0.0){return ub;}}let da=vec2f(-2.0,l+q);let Va=vec2f((ia.x+da.x)*0.5,l);let Qf=ia.x-da.x;let Gb=i32(Qf/sb);for(var Ua=1;Ua<Gb;Ua++){let f=f32(Ua)/f32(Gb);let Uf=(1.0-f)*(1.0-f)*ia.x+2.0*(1.0-f)*f*Va.x+f*f*da.x;let Vf=(1.0-f)*(1.0-f)*ia.y+2.0*(1.0-f)*f*Va.y+f*f*da.y;let Qa=Vf;let Sa=l+q;let Yf=max((Qa-Sa)*0.5,0.001);let Zf=(Qa+Sa)*0.5;if (Qa>Sa){let ag=n(g-vec2f(Uf,Zf),vec2f(qb,Yf));if (ag<=0.0){return ub;}}}let W=vec2f(2.0,l+q);let Na=vec2f((fa.x+W.x)*0.5,l);let dg=W.x-fa.x;let Eb=i32(dg/sb);for(var rb=1;rb<Eb;rb++){let h=f32(rb)/f32(Eb);let hg=(1.0-h)*(1.0-h)*fa.x+2.0*(1.0-h)*h*Na.x+h*h*W.x;let ig=(1.0-h)*(1.0-h)*fa.y+2.0*(1.0-h)*h*Na.y+h*h*W.y;let vb=ig;let Wa=l+q;let lg=max((vb-Wa)*0.5,0.001);let mg=(vb+Wa)*0.5;if (vb>Wa){let ng=n(g-vec2f(hg,mg),vec2f(qb,lg));if (ng<=0.0){return ub;}}}let og=Ja(g,za,ob,ta);let pg=abs(og.dist)-Pa;if (pg<=-0.001){return vec3f(1.0);}let qg=Ja(g,ia,Va,da);let rg=abs(qg.dist)-Pa;if (rg<=-0.001){return vec3f(1.0);}let sg=Ja(g,fa,Na,W);let tg=abs(sg.dist)-Pa;if (tg<=-0.001){return vec3f(1.0);}return vec3f();}@compute @workgroup_size(16,16) fn main_image(@builtin(global_invocation_id) ca:vec3u){let Z=textureDimensions(screen);if (ca.x>=Z.x||ca.y>=Z.y){return;}let rf=vec2f(f32(ca.x)+.5,f32(Z.y-ca.y)-.5);let We=(rf*2.0-vec2<f32>(Z))/f32(Z.y);var Aa=ee;let Ad=1.0;const rd=1.0;const hd=a(vec2f(0.0),0.0,vec2f(rd),vec2f(0.0));Aa=Uc(We,hd);Aa=pow(Aa,vec3f(2.2));textureStore(screen,ca.xy,vec4f(Aa,Ad));}